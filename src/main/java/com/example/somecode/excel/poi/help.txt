1.介绍
不管是JXL，还是POI，它们在解析Excel文件上的思想流程都是差不多的，先读取工作簿 → 工作表 → 行 → 单元格。
对于POI，可以表示为Workbook → Sheet → Row → Cell
HSSF – 提供读写Excel格式（03）xls文件
XSSF – 提供读写Excel OOXML格式（07）xlsx文件

HSSF仅能保存65535行数据，XSSF无限制但速度比较慢，因此可以使用优化后的XSSF，即SXSSF（可以写非常大的数据量，如100万条甚至更多条，
写数据速度快，占用更少的内存）
会产生临时文件，需要清理临时文件（fileOutputStream.close();）（默认由100条记录被保存在内存中，如果超过这数量，
则最前面的数据被写入临时文件，如果向自定义内存中数据的数量，可以使用new SXSSFWorkbook（数量）

当数据量超出65536条后，在使用HSSFWorkbook或XSSFWorkbook，程序会报OutOfMemoryError：Javaheap space;内存溢出错误。
无论是行还是列，或者单元格字符长度，都有限制，在实际开发时需要注意

HSSF(03)读取xlsx(07)文件会报错，XSSF(07)读取xls(03)文件会报错，互不兼容
使用上差异如下，其他基本一样：
Workbook workbook = new HSSFWorkbook(inputStream);
Workbook workbook = new XSSFWorkbook(inputStream);

row和cell都是从0开始编号的

workbook一定要关闭，比如当你打开一个 xls,如果没有关闭，再一次操作同一xls就会出问题

2.依赖
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>3.16</version>
</dependency>

<!-- 解析Excel 2007及以上版本文件必须加上下面的 -->
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>3.16</version>
</dependency>

3.一些方法
获取富文本内容
row.getCell(0).getRichStringCellValue()


4.SXSSF相关
SXSSFWorkBook 是只写的，不支持读取
写文件时，需要创建xlsx文件，否则会有异常
当数据量超过1000条时就会调用SXSSFWorkbook方法（可适当调整），从而解决了海量的数据导出会发生内存溢出的问题。

SXSSFWorkbook.DEFAULT_WINDOW_SIZE默认值是100，表示在内存中最多存在100个Row对象，当写第101个Row对象的时候就会
把第1个Row对象以XML格式写入AppData\Local\Temp路径下的临时文件中，后面的以此类推，始终保持内存中
最多存在100个Row对象。

默认的临时文件存放目录：
windows下：C:\Users\xx\AppData\Local\Temp\poifiles文件夹下，生成一个叫poi-sxssf-sheet**************的文件
Linux系统下：会在/tmp/poifiles文件下生成该临时文件

官方提示导出EXCEL后应该调用wb.dispose()来删除之前保存的临时文件。


5.富文本HSSFRichTextString
创建HSSFRichTextString单元格的方式很重要，有时，创 建太多的HSSFRichTextString单元格会导致Excel 2003和 更低版本在
更改单元格的颜色，然后保存Excel文件时崩溃

第一种：
HSSFCell hssfCell = row.createCell(idx);
RichTextString str = new HSSFRichTextString("富文本");
str.applyFont(0, 1, font1);
str.applyFont(1, 3, font2);
hssfCell.setCellValue(str);

第二种：
// 创建单元格样式style, 并为其分配第一个字体font1
CellStyle style = workbook.createCellStyle();
style.setFont(font1);
Cell cell = row.createCell(idx);
cell.setCellStyle(style);
RichTextString str = new HSSFRichTextString("富文本");
// font2将覆盖font1
str.applyFont(6, 13, font2);
cell.setCellValue(str);

要将不同的字体Font应用于富文本字符串的不同部分一般采用第二种方法


n.附录：
Workbook workbook = WorkbookFactory.carete(file);


遗留问题：
是否需要flush
结合bean对象的读写
HSSFRichTextString
easyExcel
